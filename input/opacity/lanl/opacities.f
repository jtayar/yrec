ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Main Program           OPACITIES
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c INTRODUCTION
c
c This program combines the H.BIN and HE.BIN extinction coefficient
c files with the Z.kap file, created with the CREATEZ.FOR program, and
c produces a set of opacity tables.  The opacity tables are grids of
c Rosseland mean opacities calcuated at user specified density and
c temperature grid points.  The specific mixuture(s) of X, Y, and Z
c are specified by the user and individuial tables are constructed for
c each mixture.
c
c The user is required to supply his/her own output routines.  Included
c here is a generic routine which prints out everything and a
c relatively sophiticated routine which creates a Vandenburg format
c opacity table.
c
c DESCRIPTION
c
c This program carries out two tasks:  (1) it combines H and He
c extinction coefficients with the Z mixture extinction coefficients, and
c then (2) it integrates the resultant extinction coefficients over
c frequency space to get the Rosseland mean opacities.
c An additional task has been added to the program: that of creating
c a complete set of tables in the Vandenburg format.  This is a non-
c trivial set of routines which should be ignored unless you require
c this format.
c
c INPUT:
c
c Program operation is controlled by the variables in the namelist
c START.OPACITIES.  The program will look for this file in your
c program directory.  The namelist file contains the names (or paths
c to the other files used by OPACITIES.FOR.  The program needs the
c three files containing the extincition coefficients for H, HE, and
c the Z mixture.  The default names are H.BIN, HE.BIN, and Z.kap,
c respectivley.
c
c When generating Vandenburg format opacites (lvand = true) then
c must have files of the Cox and Stewart opacity tables in Vandenburg
c format.
c
c OUTPUT:
c
c The program's output is controlled by the user.  This version can output
c three different sets of opacity tables.  The first set, used primarily,
c for debugging contains, uninterpolated lists of the density, temperature
c eta, opacity, energy, pressure, and epsilon.  As for all outputted
c tables a unique file is used for each composition (X, Y, Z).  The
c first set of tables are generated by the wrtgrid routine.  The output
c files are identified as whatever.GRID1, whatever.GRID2, etc. with one
c file for each mixture (X, Y, Z).  These tables are in Eta, Temp space.
c
c The second set contain lists, covering the entire density, temp range
c of the LASL extinction coefficients, of the opacities, pressure, energy,
c and epsilon.  These tables are in density, temp plane. The output files
c are identified as whatever.TABLE1, whatever.TABLE2, etc. with one file
c for each each mixture (X, Y, Z). The wrttable subroutine produces this
c output.

c The final set is a complete Vandenburg format opacity table.  Part
c of the table is filled with Cox and Stewart opacites.  See the
c wrtvand subroutine for details.  If the lvand flag is 'T' then
c this output will be generated, and, in addition, will override
c other options.
c Errors during execution are written to "DEBUG.OPACITIES"
c
c INPUT PARAMETER (NAMELIST)
c lextra - if true output will contain energy, pressure and epsilon
c          as will as opacity, if false will only output opacity.
c gpstfx - characters that will be prepended to GRID file names.
c tpstfx - characters that will be prepended to TABLE file names.
c zfile - full file name of z mixture of extinction coefficients created
c         using CREATEZ.FOR
c hfile - full file name of H extinction coefficients (usually H.BIN).
c hefile - full file name of HE extincition coefficients (usually HE.BIN).
c lvand - if true will create Vandeburg format opapcity tables, if false
c         will not.
c
c if lvand is true then the following variables are used:
c      zforvan - The specific value of Z for Vandenburg opacity table.
c      zforcox - The specific value of Z for the appended Cox tables.
c                Normally this number should be the same as zforvan.
c      ldoint - if true then fill gaps in opacity table by using cubic
c               spline interpolation, if false then fill gaps by using
c               nearest neighbor's value.
c      numcox - number of Cox and Stewart Vandenburg format opacity
c               tables available.
c      coxz(1),...,coxz(numcox) - the Z for the Cox and Stewart opacity
c               tables.
c      coxfnm(1),...,coxfnm(numcox) - the names of the Cox and Stewart
c                opacity table files.
c      vandfnm - name of the output file to contain the Vandenburg format
c                opacity table.
c
c numofxyz - number of mixtures (X, Y, Z) requested. (ignored if lvand='T')
c xa(1),...,xa(numofxyz) - H mass fraction for the mixtures. (ignored
c                          if lvand='T')
c za(1),...,za(numofxyz) - Z mass fraction for the mixtures. (ignored
c                          if lvand='T')
c numrho - number of densities
c rho(1),...,rho(numrho) - opacities will be calculated at these densities
c
c numt - number of temperatures
c t(1),...,t(numt) - opacities will be caluculated at these temperatures.
c IMPORTANT: No interpolation is done in T hence numt and t(i) are ignored.
c
c az(20) and bz(20) the relative abundances of the z mixture normalized
c      so that az(3)+az(4)+...+az(2) = 1.0.  Similarly for bz.  az are
c      relative number fraction and bz are the relative mass fraction. 
c
c  NOMENCLATURE:  grids are arrays in eta, T of unintepolated opacities.
c                 tables are arrays in density, T of interpolated opacites.
c
C  MODIFICATION HISTORY:
c     January 25, 1991
c         added output of Z mixture ratios to Vandenburg format and
c         generic output.
c
c
      implicit real*4(a-h,o-z)
      implicit integer*4 (i-n)
      logical lextra, lvand, ldbug, ldoint
c MXTB = maximum number of tables that this program can calculate at one
c time and MXTRHO = maximum number of T and rho in opacity tables.
      parameter(MXTB=10,MXTRHO=100)
      character*64 hfile, hefile, zfile
      character*32 gpstfx, tpstfx
      character*2 element(20), elemlasl(20)
      character*64 coxfnm(10), vandfnm
      dimension coxz(10), az(20), bz(20), awt1(20)
      common /weights/ xa(MXTB), ya(MXTB), za(MXTB), t(MXTRHO),
     1  rho(MXTRHO), xn(MXTB), yn(MXTB), zn(MXTB),
     2  z(3), awt(3), datmix(100),
     3  sumam(MXTB), sumaz(MXTB)
c output tables calculated by interpolating the grids
      common /table/ rhot(MXTB, MXTRHO, MXTRHO),
     1    rkapt(MXTB, MXTRHO, MXTRHO), et(MXTB, MXTRHO, MXTRHO),
     2    pt(MXTB, MXTRHO, MXTRHO), epst(MXTB, MXTRHO, MXTRHO)
c input grids
      common /grid/ rhog(MXTB, 50, 50), tg(MXTB, 50),
     1    rkapg(MXTB, 50, 50), eg(MXTB, 50, 50),
     2    pg(MXTB, 50, 50), epsg(MXTB, 50, 50),
     3    etag(MXTB, 50, 50)
      common /elem/element, elemlasl
c indicies for the grids
      common/index/ itx, iex(50)
      common /io/ioz, ioh, iohe, iodbug, iot, iog, iocoxl, iocoxh,iodv
      data z/ 1., 2., 0./
      data awt/ 1.008, 4.0026, 0./
      data awt1/ 1.008, 4.0026, 12.0111, 14.0067, 15.9994, 20.179,
     1 22.9898, 24.305, 26.9815, 28.086, 30.9738, 32.06, 35.453, 39.948,
     2 40.08, 47.9, 51.996, 54.938, 55.847, 58.71    /
      data element/' H','HE',' C',' N',' O','NE','NA',
     1             'MG','AL','SI',' P',' S','CL','AR',
     2             'CA','TI','CR','MN','FE','NI'/
      data elemlasl/'H ','HE','C ','N ','O ','NE','NA',
     1             'MG','AL','SI','P ','S ','CL','AR',
     2             'CA','TI','CR','MN','FE','NI'/
c define namelist
      namelist /start/numofxyz, xa, za, numt, t, numrho, rho,
     1 gpstfx, tpstfx, zfile, hfile, hefile, coxfnm, coxz, lextra,
     2 vandfnm, zforvan, zforcox, numcox, ldoint, lvand
c logical units for io
      iost = 1
      ioh = 11
      iohe = 12
      ioz = 13
      iog = 2
      iot = 3
      iodbug = 4
      iocoxl = 14
      iocoxh = 15
      iodv = 16
      open(iodbug, FILE='DEBUG.OPACITIES', CARRIAGECONTROL='LIST',
     1     STATUS='UNKNOWN', FORM='FORMATTED')
      rewind iodbug
      open(iost, FILE='START.OPACITIES', CARRIAGECONTROL='LIST',
     1     STATUS='OLD', FORM='FORMATTED')
      lextra = .FALSE.
      read(iost, NML=start)
      close(iost)
c DEBUG  make sure namelist is working.
c     write(iodbug, 71) numofxyz,lextra, zfile, gpstfx,
c    1  tpstfx, xa, za, numt, t, numrho, rho
c  71 format(' numofxy=', i3, ' lextra=',l1,
c    1 ' zfile=', a64, /,' gpstfx=',a32,/,
c    1 ' tpstfx=', a32, /,' xa=', 5(/,1p2e20.5),/,' ya=',
c    2 5(/,1p2e20.5), /, ' numt =', i5, '  t=',
c    3 25(/,1p4e19.5), /, ' numrho =', i5, '  rho=',
c    4 25(/,1p4e19.5))
c If creating a Vandenberg format table then reset the following:
       if (lvand) then
	  numofxyz=5
	  xa(1) = 1.0e-8
	  za(1) = zforvan
	  xa(2) = 0.20
	  za(2) = zforvan
	  xa(3) = 0.50
	  za(3) = zforvan
	  xa(4) = 0.80
	  za(4) = zforvan
	  xa(5) = 1.0-zforvan-0.001
	  za(5) = zforvan
	  numrho = 25
	  do i=1, numrho
	     rho(i) = 10.0**(-14+i)
	  end do
      endif
c read first record of z tape to determine average awt and z
      open (ioz, FILE=zfile,
     1      FORM='UNFORMATTED',STATUS='OLD',READONLY)
      call tprdid(ioz, 20, ierr, .TRUE.)
      read (ioz, end=3002 ) datmix
      rewind ioz
c  relative abundances of z mixture
      do i=1, 20
	 az(i) = datmix(49+i)
      end do
      sumamo = datmix(2)
      do i=3, 20
	bz(i) = az(i) * awt1(i) / sumamo
      end do
      z(3) = datmix(2)
      awt(3) = datmix(3)
      bz(1) = 0.0
      bz(2) = 0.0
      az(1) = 0.0
      az(2) = 0.0
c  convert mass fractions to number fractions
      do i=1, numofxyz
	 ya(i) = 1.0 - (xa(i) + za(i))
	 sumam(i)= 1.0/(xa(i)/awt(1) + ya(i)/awt(2) + za(i)/awt(3))
	 xn(i) = xa(i)*sumam(i)/awt(1)
	 yn(i) = ya(i)*sumam(i)/awt(2)
	 zn(i) = za(i)*sumam(i)/awt(3)
	 sumaz(i) = xn(i)*awt(1)+yn(i)*awt(2)+zn(i)*awt(3)
      end do
c open h, he, and z mixture files and read header id.
      open(ioh, FILE=hfile, STATUS='OLD', FORM='UNFORMATTED',
     1  READONLY)
      open(iohe, FILE=hefile, STATUS='OLD', FORM='UNFORMATTED',
     1  READONLY)
      call tprdid(ioh, 1, ierr, .FALSE.)
      call tprdid(iohe, 2, ierr, .FALSE.)
      call tprdid(ioz, 20, ierr, .TRUE.)
      call combine(numofxyz, lextra)
      close (ioh)
      close (iohe)
      close(ioz)
c
c     wrtgrid outputs raw grids; primarrily useful for debugging
c     call wrtgrid(iog, numofxyz, lextra, gpstfx)
c
c     interpolate tables to requested array of density and defaulT
c     temps.
      call interp(numofxyz, numt, numrho, lextra)
c     write out interpolated tables.
      call wrttab(iot, numofxyz, numrho, lextra, tpstfx)
 3002 continue
      if (lvand) then
	 call wrtvand(zforcox, zforvan, coxz, bz, coxfnm, 
     *                numcox, numrho, vandfnm, ldoint)
      end if
      stop
      end
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Subroutine:          TPRDID  
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c This routine reads the first 8 bytes of a element or mixture
c file and verifies that it is the correct file.
c
      subroutine tprdid(io, num, ierror, lmix)
      character*4 id1, id2
      logical lmix
      character*2 element(20), elemlasl(20)
      common /elem/ element, elemlasl
      read(io) id1, id2
      if (lmix) then
	 if((id1(1:2).eq.element(3)) .and. (id2(3:4)
     1       .eq. element(num))) then
	     ierror = 0
	 else
	     ierror = 1
	 endif
      else
	 if (id1(3:4) .eq. elemlasl(num)) then
	     ierror = 0
	 else
	     ierror = 1
	 end if
      end if
      return
      end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Subroutine:          COMBINE
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c This routine adds together the two elements h and he and the
c mixture z in the proportions given by the vectors xa, ya, and za.
c The resultant opacity coefficients are integrated to produce a final
c set of tables, one table for each xa, ya, za, at the eta rho values
c of the h, he, and z files.
      subroutine combine(numofxyz, lextra)
      logical lextra
      parameter(MXTB=10,MXTRHO=100)
      dimension datmixh(100), datmixhe(100), datmixz(100),
     1          dtuh(2000), dtuhe(2000), dtuz(2000)
      dimension itemph(100), itemphe(100), itempz(100)
c input stuff
      dimension wr(2000), dtu(2000)
      common /weights/ xa(MXTB), ya(MXTB), za(MXTB), t(MXTRHO),
     1  rho(MXTRHO), xn(MXTB), yn(MXTB), zn(MXTB),
     2  z(3), awt(3), datmix(100),
     3  sumam(MXTB), sumaz(MXTB)
c output tables calculated by interpolating the grids
      common /table/ rhot(MXTB, MXTRHO, MXTRHO),
     1    rkapt(MXTB, MXTRHO, MXTRHO), et(MXTB, MXTRHO, MXTRHO),
     2    pt(MXTB, MXTRHO, MXTRHO), epst(MXTB, MXTRHO, MXTRHO)
c indices for the grids
      common/index/ itx, iex(50)
c input grids
      common /grid/ rhog(MXTB, 50, 50), tg(MXTB, 50),
     1    rkapg(MXTB, 50, 50), eg(MXTB, 50, 50),
     2    pg(MXTB, 50, 50), epsg(MXTB, 50, 50),
     3    etag(MXTB, 50, 50)
      common /io/ioz, ioh, iohe, iodbug, iot, iog,iocoxl, iocoxh,iodv
      equivalence (datmixh(1), itemph(1)),
     1            (datmixhe(1), itemphe(1)),
     2            (datmixz(1), itempz(1))
c setup wr vector
      ui = 0.01
      dui = 0.01
      wconst = 0.0384974334
      do i=1, 2000
	 emu = exp(-ui)
	 wr(i) = ui**7*emu/(1.0-emu)**3
	 ui = ui + dui
      end do
      read(ioh, end=2222) datmixh, dtuh
      read(iohe, end=2222) datmixhe, dtuhe
      read(ioz, end=2222) datmixz, dtuz
      etah = datmixh(5)
      etahe = datmixhe(5)
      etaz = datmixz(5)
      tevh = datmixh(4)
      tevhe = datmixhe(4)
      tevz = datmixz(4)
      itx = 1
      iex(itx) = 0
      tevold = tevh
 1111 continue
      if ((etah .eq. etahe) .and. (etah. eq. etaz) .and.
     1  (tevh .eq. tevhe) .and. (tevh .eq. tevz)) then
c all three files match up so add them together
	 if (tevh .ne. tevold) then
	     tevold = tevh
	     itx = itx+1
	     iex(itx) = 0
	 end if
	 iex(itx) = iex(itx)+1
	 capf = datmixh(6)
	 rhoz = datmixh(7)
	 rdz = datmixh(17)
	 rdz = rdz * 5.29166e-9
	 fne = datmixh(24)
	 pz = datmixh(10)
	 amuh = datmixh(3)
	 amuhe = datmixhe(3)
	 amuz = datmixz(3)
	 capnfh = datmixh(8)
	 capnfhe = datmixhe(8)
	 capnfz = datmixz(8)
	 etotzh = datmixhe(11)
	 etotzhe = datmixhe(11)
	 etotzz = datmixz(11)
	 z2barh = datmixh(25)
	 z2barhe = datmixhe(25)
	 z2barz = datmixz(25)
	 excih = datmixh(36)
	 excihe = datmixhe(36)
	 exciz = datmixz(36)
	 feta = ffeta(etah)
	 pkt = tevh * 1.60209e-12
	 pezl = log10(0.66666666)+log10(fne)+log10(feta)
	1       -log10(capf)+log10(pkt)
c Numbers excede range of Vax
	 if (pezl .gt. 3.6e1) pezl = 3.6e1
	 if (pezl .lt. -3.6e1) pezl = -3.6e1
	 pez = 10.0**pezl
	 excih = (excih-2.15e12)*amuh
	 excihe = (excihe-2.15e12)*amuhe
	 exciz = (exciz-2.15e12)*amuz
	 t32 = (tevh/13.6048)**1.5
	 pe = pez
	 do i=1, numofxyz
	    en = 1.44782e12 * tevh/sumam(i)
	    sumexc = xn(i)*excih+yn(i)*excihe+zn(i)*exciz
	    tfree = capnfh*xn(i)+capnfhe*yn(i)+capnfz*zn(i)
	    sumaf2 = xn(i)*capnfh*capnfh+yn(i)*capnfhe*capnfhe
	1               +zn(i)*capnfhz*capnfhz
	    sumaz2 = xn(i)*z2barh+yn(i)*z2barhe+zn(i)*z2barz
c Rosseland mean sum over frequencies
	    do id=1, 2000
	       dtu(id) = dtuh(id)*xn(i)+dtuhe(id)*yn(i)
	1                    +dtuz(id)*zn(i)
	    end do
	    rhomix = 0.5676887*capf*t32*sumam(i)/tfree
	    zstar1 = sumaf2/tfree + 1.0
	    rdebye = 7.433385e2 * sqrt(tevh/(fne*zstar1))
	    rava = 1.0e-8*(0.396396588*sumam(i)/rhomix)**0.33333333
	    rmax = max(rava, rdebye)
	    epsi = 1.44e-7 * (1.0 + tfree) / (rmax * tevh)
	    pn = fne * pkt /tfree
	    ee = 1.5 * pe / rhomix
	    fnmax = max(2.0, tfree + sumaz2/tfree)
	    a1=(4.2e-7*fnmax/(tevh*rmax)+1.0)**0.6666666-1.0
	    epl = -2.413e11*tfree*tevh*a1
	1            *(1.0+tfree)/(sumam(i)*fnmax)
	    ppl = 0.3333333*rhomix*epl
	    pmix = pn + pe + ppl
	    sumexc = sumexc/sumam(i) + 2.15e12
	    emix = en + ee + epl + sumexc
c make grid entry
	    tryd = tevh/13.6048
	    arho = sumam(i)*tryd*2.1000e-7
	    tri = 0.0
	    tpi = 0.0
	    uplas = 2.1179*sqrt(tfree*rhomix/sumam(i))/tryd
	    nplas = uplas*100.
	    if (nplas .eq. 0) nplas = 1
	    ui = nplas*0.01
	    tri = wr(nplas)/(dtu(nplas)*2.0)
	    if (uplas .lt. 0.01) tri = wr(nplas)/dtu(nplas)
	    npp = nplas + 1
	    do j=npp, 2000
	       tri = tri+wr(j)/dtu(j)
	    end do
	    tri = wconst*0.01*(tri-wr(2000)/(dtu(2000)*2.0))
	    trk = 1.0/(arho*tri)
	    if (trk .gt. rkapmx) rkapmx = trk
	    it = itx
	    ie = iex(itx)
	    rkapg(i,ie,it) = alog10(trk)
	    tg(i,it)= tevh
	    rhog(i,ie,it) = alog10(rhomix)
	    etag(i,ie,it) = etah
	    if (lextra) then
	       epsg(i,ie,it) = epsi
	       eg(i,ie,it) = emix
	       pg(i,ie,it) = alog10(pmix)
	    end if
 3333    end do
	 read(ioh, end=2222) datmixh, dtuh
	 read(iohe, end=2222) datmixhe, dtuhe
	 read(ioz, end=2222) datmixz, dtuz
	 etah = datmixh(5)
	 etahe = datmixhe(5)
	 etaz = datmixz(5)
	 tevh = datmixh(4)
	 tevhe = datmixhe(4)
	 tevz = datmixz(4)
	 go to 1111
      else
c files do not match
c        write(iodbug,*)' recs do not match at: ',etah, tevh,
c    1   etahe, tevhe, etaz, tevz
	 if (tevh .lt. tevz) then
	    do while (tevh .lt. tevz)
	       read(ioh, end=2222) datmixh, dtuh
	       etah = datmixh(5)
	       tevh = datmixh(4)
	    end do
	    go to 1111
	 else if (tevhe .lt. tevz) then
	    do while (tevhe .lt. tevz)
	       read(iohe, end=2222) datmixhe, dtuhe
	       etahe = datmixhe(5)
	       tevhe = datmixhe(4)
	    end do
	    go to 1111
	 else if (tevh .gt. tevz) then
	    do while (tevz .lt. tevh)
	       read(ioz, end=2222) datmixz, dtuz
	       etaz = datmixz(5)
	       tevz = datmixz(4)
	    end do
	    go to 1111
	 else if (tevhe .gt. tevz) then
	    do while(tevz .lt. tevhe)
	       read(ioz, end=2222) datmixz, dtuz
	       etaz = datmixz(5)
	       tevz = datmixz(4)
	    end do
	    go to 1111
	 else
	    if (etah .lt. etaz) then
	       do while((etah .lt. etaz) .and. (tevh .eq. tevz))
		  read(ioh, end=2222) datmixh, dtuh
		  etah = datmixh(5)
		  tevh = datmixh(4)
	       end do
	       go to 1111
	    else if (etahe .lt. etaz) then
	       do while((etahe .lt. etaz) .and. (tevhe .eq. tevz))
		  read(iohe, end=2222) datmixhe, dtuhe
		  etahe = datmixh(5)
		  tevhe = datmixh(4)
	       end do
	       go to 1111
	    else if (etah .gt. etaz) then
	       do while((etaz .lt. etah) .and. (tevh .eq. tevz))
		  read(ioz, end=2222) datmixz, dtuz
		  etaz = datmixz(5)
		  tevz = datmixz(4)
	       end do
	       go to 1111
	    else
	       go to 1111
	    end if
	 end if
      end if
 2222 continue
c finished reading tape
      return
      end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      SUBROUTINE:    wrtgrid
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c This routine writes out the grids for reference purposes only.
c
      subroutine wrtgrid(iog, numofxyz, lextra, gpstfx)
      logical lextra
      parameter(MXTB=10,MXTRHO=100)
      character*32 gpstfx
      character*20 prefx
      character*64 filenm
      common /weights/ xa(MXTB), ya(MXTB), za(MXTB), t(MXTRHO),
     1  rho(MXTRHO), xn(MXTB), yn(MXTB), zn(MXTB),
     2  z(3), awt(3), datmix(100),
     3  sumam(MXTB), sumaz(MXTB)
      common /grid/ rhog(MXTB, 50, 50), tg(MXTB, 50),
     1    rkapg(MXTB, 50, 50), eg(MXTB, 50, 50),
     2    pg(MXTB, 50, 50), epsg(MXTB, 50, 50),
     3    etag(MXTB, 50, 50)
      do i=1, numofxyz
	 if (i .le. 9) then
	    write(prefx,100)i
  100       format('GRID',i1,'.')
	 else
	    write(prefx, 101)i
  101       format('GRID',i2,'.')
	 end if
	 filenm = prefx // gpstfx
	 open (iog, FILE=filenm, CARRIAGECONTROL='LIST',
	1      STATUS='NEW', FORM='FORMATTED')
	 write(iog,190) xa(i), za(i)
  190    format(' X=', 1pe10.4, '  Z=', 1pe10.4)
	 write(iog, 201)
  201    format(' Density')
	 do j=1, 50
	    write(iog, 200) j, (rhog(i,j,k), k=1, 50)
  200       format(i5, 1p5e12.5, 9(/,5x,1p5e12.5))
	 end do
	 write(iog, 202)
  202    format(' Temperature')
	 j = 1
	 write(iog, 200)j, (tg(i,k), k=1, 50)
	 write(iog, 207)
  207    format(' Eta')
	 do j=1, 50
	    write(iog, 200) j, (etag(i,j,k), k=1, 50)
	 end do
	 write(iog, 203)
  203    format(' Opacity')
	 do j=1, 50
	    write(iog, 200) j, (rkapg(i,j,k), k=1, 50)
	 end do
	 if (lextra) then
	    write(iog, 204)
  204       format(' Energy')
	    do j=1, 50
	       write(iog, 200) j, (eg(i,j,k), k=1, 50)
	    end do
	    write(iog, 205)
  205       format(' Pressure')
	    do j=1, 50
	       write(iog, 200) j, (pg(i,j,k), k=1, 50)
	    end do
	    write(iog, 206)
  206       format(' Epsilon')
	    do j=1, 50
	       write(iog, 200) j, (epsg(i,j,k), k=1, 50)
	    end do
	 end if
	 close (iog)
      end do
      return
      end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  SUBROUTINE: interp
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c This routine interpolates the eta, T grid of opacities at the
c user specified rho, T values and returns the result in the
c "table" arrays.
c Interpolation proceeds as follows:
c 1.  Get a T row (run of eta) from the opacity grid.
c 2.  Interpolate row to requested density values (eta is function of T,rho)
c 3.  Repeat step 2 for all T rows
c
c Interpolation is not done in T, default values of T are used, i.e. the
c the T values of the orginal extinction coefficients.
c
      subroutine interp(numofxyz, numt, numrho, lextra)
      logical lextra
      parameter(MXTB=10,MXTRHO=100)
      dimension datmixh(100), datmixhe(100), datmixz(100),
     1          dtuh(2000), dtuhe(2000), dtuz(2000)
      dimension itemph(100), itemphe(100), itempz(100)
c Vectors to store rows before calling spline routines
      dimension xrho(50), xkap(50), xe(50), xp(50), xeps(50),
     1          xeta(50)
c Vectors to store derivatives used by spline routines
      dimension dkap(50), de(50), dp(50), deps(50),
     1          deta(50)
c Arrays to store interpolated in rho values
      dimension tkap(MXTRHO), te(MXTRHO), tp(MXTRHO),
     1          teps(MXTRHO), teta(MXTRHO)
c input stuff
      common /weights/ xa(MXTB), ya(MXTB), za(MXTB), t(MXTRHO),
     1  rho(MXTRHO), xn(MXTB), yn(MXTB), zn(MXTB),
     2  z(3), awt(3), datmix(100),
     3  sumam(MXTB), sumaz(MXTB)
c output tables calculated by interpolating the grids
      common /table/ rhot(MXTB, MXTRHO, MXTRHO),
     1    rkapt(MXTB, MXTRHO, MXTRHO), et(MXTB, MXTRHO, MXTRHO),
     2    pt(MXTB, MXTRHO, MXTRHO), epst(MXTB, MXTRHO, MXTRHO)
c input grids
      common /grid/ rhog(MXTB, 50, 50), tg(MXTB, 50),
     1    rkapg(MXTB, 50, 50), eg(MXTB, 50, 50),
     2    pg(MXTB, 50, 50), epsg(MXTB, 50, 50),
     3    etag(MXTB, 50, 50)
c indices for the grids
      common/index/ itx, iex(50)
      common /io/ioz, ioh, iohe, iodbug, iot, iog,iocoxl, iocoxh,iodv
c Outer loop: do all compositions (X, Y, Z)
      do ic=1, numofxyz
c Interpolate in rho (T values of original opacity tapes)
	 do j=1, itx
	    nrho = iex(j)
c Dump a row (fixed T) into a vector
	    do i=1, nrho
	       xrho(i) = rhog(ic, i, j)
	       xkap(i) = rkapg(ic, i, j)
	       xeta(i) = etag(ic, i, j)
	       if (lextra) then
		  xe(i) = eg(ic, i, j)
		  xp(i) = pg(ic, i, j)
		  xeps(i) = epsg(ic, i, j)
	       end if
	    end do
c Get derivatives for spline interpolation
	    call spline(xrho, xkap, nrho, 1.0e30, 1.0e30, dkap)
	    call spline(xrho, xeta, nrho, 1.0e30, 1.0e30, deta)
	    if (lextra) then
	       call spline(xrho, xe, nrho, 1.0e30, 1.0e30, de)
	       call spline(xrho, xp, nrho, 1.0e30, 1.0e30, dp)
	       call spline(xrho, xeps, nrho, 1.0e30, 1.0e30, deps)
	    end if
c Interpolate at the numrho densities
	    do i=1, numrho
	       rrho = alog10(rho(i))
	       if(rrho .ge. xrho(1) .and.
     1            rrho .le. xrho(nrho)) then
		  call splint(xrho, xkap, nrho, dkap, rrho, rkap)
		  rkapt(ic, i, j) = 10.0**rkap
		  if (lextra) then
		     call splint(xrho, xe, nrho, de, rrho, re)
		     et(ic, i, j) = re
		     call splint(xrho, xp, nrho, dp, rrho, rp)
		     pt(ic, i, j) = rp
		     call splint(xrho, xeps, nrho, deps, rrho, reps)
		     epst(ic, i, j) = reps
		  end if
	       else if (rrho .lt. xrho(1)) then
		  rkapt(ic, i, j) = 0.0
		  if (lextra) then
		     et(ic, i, j) = 0.0
		     pt(ic, i, j) = 0.0
		     epst(ic, i, j) = 0.0
		  end if
	       else
c Put extrapolation routine in here (DBG Warning, Tests show that you
c should not extrapolate the tables because of K-edges.)
		  rkapt(ic, i, j) = 0.0
		  if (lextra) then
		     et(ic, i, j) = 0.0
		     pt(ic, i, j) = 0.0
		     epst(ic, i, j) = 0.0
		  end if
	       end if
	    end do
	 end do
c
c Insert interpolation in T routines here if you want opacities at your
c own set of T values.
      end do
      return
      end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  SUBROUTINE spline
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Taken from Numerical Recipes, Press et al, p88
c Given arrays x and y of length n containing a tabulated funcition,
c i.e. y[i] = f(x[i]) with x[1] < x[2] < ... x[n], and given values
c yp1 and ypn for the first derivative of the interpolating function
c at points 1 and n, respectively, this routine returns and array y2
c of length n which contains the second derivatives of the interpolating
c function at the tabulated points x[i].  If yp1 and/or ypn are equal
c to 1.0e30 or larger, the routine is signalled to set the corresponding
c boundary condition for a natural spline, with zero second derivative
c on that boundary.
      subroutine spline(x, y, n, yp1, ypn, y2)
      parameter(nmax=100)
      dimension x(n), y(n), y2(n), u(nmax)
      if (yp1 .gt. 0.99e30) then
	 y2(1) = 0.0
	 u(1) = 0.0
      else
	 y2(1) = -0.5
	 u(1) = (3./(x(2)-x(1)))*((y(2)-y(1))/(x(2)-x(1))-yp1)
      endif
      do i=2, n-1
	 sig = (x(i)-x(i-1))/(x(i+1)-x(i-1))
	 p = sig*y2(i-1)+2.0
	 y2(i) = (sig-1.0)/p
	 u(i) = (6.0*((y(i+1)-y(i))/(x(i+1)-x(i))-(y(i)-y(i-1))
     1          /(x(i)-x(i-1)))/(x(i+1)-x(i-1))-sig*u(i-1))/p
      end do
      if (ypn .gt. 0.99e30) then
	 qn = 0.0
	 un = 0.0
      else
	 qn = 0.5
	 un = (3./(x(n)-x(n-1)))*(ypn-(y(n)-y(n-1))/(x(n)-x(n-1)))
      end if
      y2(n) = (un-qn*u(n-1))/(qn*y2(n-1)+1.0)
      do k=n-1, 1, -1
	 y2(k) = y2(k)*y2(k+1)+u(k)
      enddo
      return
      end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c SUBROUTINE splint
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Taken from Numerical Recipes, Press, et al, p89.
c Given the arrays xa and ya of length n, which tabulate a function
c (with the xa[i]'s in order), and given the array y2a, which is the
c output of spline above, and given a value of x, this routine returns
c a cubic-spline interpolated value y.
      subroutine splint(xa, ya, n, y2a, x, y)
      dimension xa(n), ya(n), y2a(n)
      klo = 1
      khi = n
    1 if (khi-klo .gt. 1) then
	 k = (khi+klo)/2
	 if (xa(k) .gt. x) then
	    khi = k
	 else
	    klo = k
	 end if
	 goto 1
      end if
      h = xa(khi) - xa(klo)
      if (h .eq. 0.) then
c error
      endif
      a = (xa(khi)-x)/h
      b = (x - xa(klo))/h
      y = a*ya(klo)+b*ya(khi)+
     1    ((a**3-a)*y2a(klo)+(b**3-b)*y2a(khi))*(h**2)/6.0
      return
      end
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c SUBROUTINE:  wrttab
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c This routine writes out the tables of opacity, etc to disk files.
c One file each is used for each composition.
c Zero entries indicate that the opacity was not
c available (i.e. calculated by LASL).
c
c The tables contain all T values, no interpolation in T is done.
c
      subroutine wrttab(iog, numofxyz, numrho, lextra, tpstfx)
      logical lextra
      parameter(MXTB=10, MXTRHO=100)
      character*32 tpstfx
      character*20 prefx
      character*64 filenm
      common /weights/ xa(MXTB), ya(MXTB), za(MXTB), t(MXTRHO),
     1  rho(MXTRHO), xn(MXTB), yn(MXTB), zn(MXTB),
     2  z(3), awt(3), datmix(100),
     3  sumam(MXTB), sumaz(MXTB)
c input grids
      common /grid/ rhog(MXTB, 50, 50), tg(MXTB, 50),
     1    rkapg(MXTB, 50, 50), eg(MXTB, 50, 50),
     2    pg(MXTB, 50, 50), epsg(MXTB, 50, 50),
     3    etag(MXTB, 50, 50)
c output tables calculated by interpolating the grids
      common /table/ rhot(MXTB, MXTRHO, MXTRHO),
     1    rkapt(MXTB, MXTRHO, MXTRHO), et(MXTB, MXTRHO, MXTRHO),
     2    pt(MXTB, MXTRHO, MXTRHO), epst(MXTB, MXTRHO, MXTRHO)
      do ic = 1, numofxyz
	 if (ic .le. 9) then
	    write(prefx, 100)ic
  100       format('TABLE', i1, '.')
	 else
	    write(prefx, 101)ic
  101       format('TABLE', i2, '.')
	 end if
	 filenm = prefx // tpstfx
	 open (iot, FILE=filenm, CARRIAGECONTROL='LIST',
     1         STATUS='NEW', FORM='FORMATTED')
	 write(iot, 190) xa(ic), ya(ic), za(ic), numrho
  190    format(' X =',1pe13.6,'  Y =',1pe13.6,'  Z =', 1pe13.6,
     1   /, i3, ' 46 (number of densities, number of temperatures)')
	 write(iot, 195) (rho(i),i=1, 50)
  195    format(/,' Densities (gm/cc):',/,(1p5e12.5))
	 write(iot, 196) (tg(ic, i), i=1, 50)
  196    format(/,' Temperatures:(eV) x11604.5 to get K',
     1    /,(1p5e12.5))
	 write(iot, 197)
  197    format(/,' Opacities (sq-cm/gm)',
     1    ' Arranged in blocks of common density')
	 do i=1, numrho
	    write(iot, 200)rho(i),(rkapt(ic, i, j), j=1, 50)
	 end do
  200    format (1pe7.1, 1p5e12.5, 9(/,7x,1p5e12.5))
	 if (lextra) then
	    write(iot, 201)
  201       format(/, 'log(Pressure) (gm/sq-cm)',
     1       ' Arranged in blocks of common density')
	    do i=1, numrho
	       write(iot, 200)rho(i), (pt(ic, i, j), j=1, 50)
	    end do
	    write(iot, 203)
  203       format(/, ' Energy (erg)',
     1       ' Arranged in blocks of common density')
	    do i=1, numrho
	       write(iot, 200)rho(i), (et(ic, i, j), j=1, 50)
	    end do
	    write(iot, 205)
  205       format(/, ' Epsilon)',
     1       ' Arranged in blocks of common density')
	    do i=1, numrho
	       write(iot, 200)rho(i), (epst(ic, i, j), j=1, 50)
	    end do
	 end if
	 close(iot)
      end do
      return
      end
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Function:               FFETA
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c This function returns ffeta calculated from a rational polynomial
c approximation.
c
      function ffeta(eta)
c     by using one of 6 polynomials i 3/2(eta)
c     is computed
      if (eta .gt. 1.e+05) go to 6000
      if (eta .gt. 10.0) go to 5000
      if (eta .gt. 3.0) go to 4000
      if (eta .gt. -2.0) go to 2000
      eeta=exp(eta)
      ffeta=((((((eeta/129.6418147-.0113402303)*eeta+.0178885437)*
     1  eeta-.03125)*eeta+.0641500298)*eeta-.176776695)*eeta+1.0)*
     2  eeta*(.75*1.77245385)
      return
 2000 ffeta=.1758009896+1.5*(((((( -.0001066018*eta-
     1  .00047150892)*eta+.00469520575)*eta+.05636582666)*
     2  eta+.268098335)*eta+.678091)*eta+.6513262112)
      return
 3000 ffeta=1.15279031+1.5*(((((( .000081733*eta-.001202982)*
     1  eta+.005151675)*eta+.0556078333)*eta+.26819)*
     2  eta+.678091)*eta)
      return
 4000 ffeta=10.3536987+1.5*((((((-.303295167e-5*eta+
     1  .16516628e-3)*eta-.42073325e-2)*eta+.0901841667)*
     2  eta+.1961444)*eta+.757064709)*eta-6.16859689)
      return
 5000 eta12=sqrt(eta)
      eta32=eta12*eta
      eta52=eta32*eta
      eta72=eta52*eta
      etasq=eta*eta
      eta112=eta72*etasq
      eta152=eta112*etasq
      ffeta=134.270211-134.270185+.4*eta52+2.4674010*
     1   eta12-.7102746/eta32-2.771862428/eta72-
     2   44.1300036/eta112-1641.825466/eta152
      return
 6000 ffeta = .4 * eta**2.5
      return
      end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      WRTVAND
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  Warning this routine is tricky.  It attempts to fully automate the
c  the creation of a Vandenburg format opacity table.  At low temps
c  where the LASL tables do not exit it will read a set of Cox and
c  Stewart tables (stored in Vandenburg format) and interpolate, linearly,
c  to get the requested Z (zforcox).  The overall metallicity of the tables
c  is specified by zforvan.  zforcox allows, if desired, a different z
c  for the T<10000K Cox opaciites.
c  This routine, therefore, requires
c  a complete set in Z of Cox and Stewart opacity tables.  We normally
c  use z tables from 0.00001 to 0.10.  Two methods are used to fill in
c  gaps.  If lintrp is true then the program will carry out cubic spline
c  interpolation or as is mostly the case, extrapolation.  If ldoint is
c  false then the routine will fill the gaps with the opacity of its
c  nearest neighbor.
c
c  The output of the table, in addition to containing the opacity tables
c  themselves also contains a header which lists the abundances used by the
c  Cox mixture, scaled to the zforvan value. (only 10 elements)
c  We have added, at the end of the tables, the full mixture used to
c  construct the tables, scaled to the zforvan values.
      subroutine wrtvand(zforcox, zforvan, coxz, bz, coxfnm, numcox, 
     1   numrho, vandfnm, ldoint)
      parameter(MXTB=10, MXTRHO=100)
      logical interp
      character*64 coxfnm(10), vandfnm
      dimension tout(29), cox(10),cr(10),dincr(29),incr(29),it(29),
     1          rkout(5, 10, 29), coxm(10)
      dimension tk(50), tr(50), dtk(50)
      dimension coxz(10), coxkh(5,10,29),coxkl(5,10,29), bz(20)
      dimension coxxl(5), coxxh(5), xkl(5), xkh(5), dxkl(5), dxkh(5)
      dimension awtcox(10), frnum(10)
      common /weights/ x(MXTB), y(MXTB), z(MXTB), ttt(MXTRHO),
     1  rho(MXTRHO), xn(MXTB), yn(MXTB), zn(MXTB),
     2  zz(3), awt(3), datmix(100),
     3  sumam(MXTB), sumaz(MXTB)
c output tables calculated by interpolating the grids
      common /table/ rhot(MXTB, MXTRHO, MXTRHO),
     1    rkap(MXTB, MXTRHO, MXTRHO), et(MXTB, MXTRHO, MXTRHO),
     2    pt(MXTB, MXTRHO, MXTRHO), epst(MXTB, MXTRHO, MXTRHO)
c input grids
      common /grid/ rhog(MXTB, 50, 50), tg(MXTB, 50),
     1    rkapg(MXTB, 50, 50), eg(MXTB, 50, 50),
     2    pg(MXTB, 50, 50), epsg(MXTB, 50, 50),
     3    etag(MXTB, 50, 50)
c indicies for the grids
      common /io/ioz, ioh, iohe, iodbug, iot, iog, iocoxl, iocoxh,iodv
c     atomic weights of C, N, O, Ne, Na, Mg, Al, Si, Ar, Fe
      data awtcox/ 12.0111, 14.0067, 15.9994, 20.179,
     1 22.9898, 24.305, 26.9815, 28.086,  39.948,
     2 55.847    /
      eVtoK = 11604.5
c mass fractions of 10 elements (originally used in Cos&Stewart tables)
c normalized to 1
c C, N, O, Ne, Na, Mg, Al, Si, Ar, Fe
      coxm(1) = 1.410e-1
      coxm(2) = 4.600e-2
      coxm(3) = 4.200e-1
      coxm(4) = 2.980e-1
      coxm(5) = 1.000e-3
      coxm(6) = 1.800e-2
      coxm(7) = 1.000e-3
      coxm(8) = 2.600e-2
      coxm(9) = 3.900e-2
      coxm(10)= 8.000e-3
c     C number fraction
      frnum(1) = datmix(52)
c     N
      frnum(2) = datmix(53)
c     O
      frnum(3) = datmix(54)
C     Ne
      frnum(4) = datmix(55)
c     Na
      frnum(5) = datmix(56)
c     Mg
      frnum(6) = datmix(57)
c     Al
      frnum(7) = datmix(58)
c     Si
      frnum(8) = datmix(59)
c     Ar
      frnum(9) = datmix(63)
c     Fe
      frnum(10) = datmix(68)
c     convert number fractions to mass fractions
      sum = 0.0
      ren = 0.0
      do i=1, 10
	  ren = ren + frnum(i)
      enddo
      do i=1, 10
	  frnum(i) = frnum(i)/ren
	  sum = sum + frnum(i) * awtcox(i)
      enddo
      do i=1, 10
	  cox(i) = frnum(i) * awtcox(i) / sum
      enddo
c Cox densities - logged
      cr(1) = -13.0
      cr(2) = -12.0
      cr(3) = -11.0
      cr(4) = -10.0
      cr(5) =  -9.0
      cr(6) =  -8.0
      cr(7) =  -7.0
      cr(8) =  -6.0
      cr(9) =  -5.0
      cr(10) = -4.0
c     DV Temps  Our Temps  Index to DG Temps
c  1  1500      1500       0
c  2  2500      2500       0
c  3  3000      3000       0
c  4  4000      4000       0
c  5  5000      5000       0
c  6  6000      6000       0
c  7  7000      7000       0
c  8  8000      8000       0
c  9  9000      9000       0
c 10  10K       10K        0       eV (x11604.5 to get Kelvin)
c 11  12K       11.6K      1     1.00
c 12  15K       14.5K      2     1.25
c 13  20K       23.2K      4     2.00
c 14  30K       29.0K      5     2.5
c 15  50K       46.4K      7     4.0
c 16  70K       69.6K      9     6.0
c 17  100K      92.8K     10     8.0
c 18  200K      174K      13    15.0
c 19  500K      464K      17    40.0
c 20  1M        1.16M     21   100.0
c 21  2M        1.74M     23   150.0
c 22  5M        4.64M     27   400.0
c 23  10M       11.6M     31  1000.0
c 24  20M       17.4M     33  1500.0
c 25  50M       46.4M     37  4000.0
c 26  100M      116M      41 10000.0
c 27  200M      174M      42 15000.0
c 28  500M      464M      44 40000.0
c 29 1000M     1160M      46  100K
c
c Setup output temperature  index
      it(1) = 0
      it(2) = 0
      it(3) = 0
      it(4) = 0
      it(5) = 0
      it(6) = 0
      it(7) = 0
      it(8) = 0
      it(9) = 0
      it(10) = 0
      it(11) = 1
      it(12) = 2
      it(13) = 4
      it(14) = 5
      it(15) = 7
      it(16) = 9
      it(17) = 10
      it(18) = 13
      it(19) = 17
      it(20) = 21
      it(21) = 23
      it(22) = 27
      it(23) = 31
      it(24) = 33
      it(25) = 37
      it(26) = 41
      it(27) = 42
      it(28) = 44
      it(29) = 46
c power of ten offset for opacities
      incr(1) = 0
      incr(2) = 0
      incr(3) = 0
      incr(4) = 0
      incr(5) = 0
      incr(6) = 0
      incr(7) = 1
      incr(8) = 1
      incr(9) = 1
      incr(10) = 2
      incr(11) = 2
      incr(12) = 2
      incr(13) = 2
      incr(14) = 2
      incr(15) = 3
      incr(16) = 3
      incr(17) = 4
      incr(18) = 4
      incr(19) = 5
      incr(20) = 6
      incr(21) = 7
      incr(22) = 8
      incr(23) = 9
      incr(24) = 10
      incr(25) = 11
      incr(26) = 12
      incr(27) = 13
      incr(28) = 14
      incr(29) = 15
      do i=1, 29
	 dincr(i) = incr(i)
      end do
c Scale Cox mixture to new Z
      do i=1, 10
c Jan 28, 1991 change zforcox to zforvan
	 cox(i) = cox(i) * zforvan
      end do
c Read in appropiate Cox tables to do linear interpolation
c of low temperature opacities in Z and cubic spline interpolation
c in X.
      call locate(coxz, numcox, zforcox, jj)
      if (jj .eq. 0) then
	 locox = 1
	 hicox = 2
      else if (jj .eq. numcox) then
	 locox = jj - 1
	 hicox = jj
      else
	 locox = jj
	 hicox = jj + 1
      end if
      open (iocoxl, FILE=coxfnm(locox), FORM='FORMATTED',
     1    CARRIAGECONTROL='LIST', STATUS='OLD',READONLY)
      open (iocoxh, FILE=coxfnm(hicox), FORM='FORMATTED',
     1    CARRIAGECONTROL='LIST', STATUS='OLD',READONLY)
      open (iodv, FILE=vandfnm, FORM='FORMATTED',
     1   CARRIAGECONTROL='LIST',  STATUS='NEW')
      zlo = coxz(locox)
      zhi = coxz(hicox)
c     write(iodbug,*) 'locox=', locox,zlo, coxfnm(locox)
c     write(iodbug,*) 'hicox=', hicox,zhi, coxfnm(hicox)
      read(iocoxl, 299)
      read(iocoxh, 299)
 299  format(1x)
      read(iocoxl, 300) (((coxkl(i, j, k),j=1,10),k=1,29),i=1,5)
      read(iocoxh, 300) (((coxkh(i, j, k),j=1,10),k=1,29),i=1,5)
 300  format(1p8e9.2)
      do i=1, 7
	 read(iocoxl, 299)
	 read(iocoxh, 299)
      end do
      read(iocoxl, 301) coxxl
      read(iocoxh, 301) coxxh
 301  format(1p5e10.3)
      write(iodbug, *) 'coxxl=', coxxl
      write(iodbug, *) 'coxxh=', coxxh
c
c Carry out spline interp in X to get X(1...5) the same as in
c the LASL tables
      do j=1, 10
c Don't waste time with high temps (i.e. k=1...10 rather than ...29)
	 do k=1, 10
	    do i=1, 5
	       xkl(i) = coxkl(i, j, k)
	       xkh(i) = coxkh(i, j, k)
	    end do
c     write(iodbug, *) 'xkl=', xkl
c     write(iodbug, *) 'xkh=', xkh
	    isize = 5
	    call spline(coxxl, xkl, isize, 1.0e30, 1.0e30, dxkl)
	    call spline(coxxh, xkh, isize, 1.0e30, 1.0e30, dxkh)
	    do i=1, 5
	       thex = x(i)
	       call splint(coxxl, xkl, isize, dxkl, thex, thekl)
	       call splint(coxxh, xkh, isize, dxkh, thex, thekh)
	       coxkl(i, j, k) = thekl
	       coxkh(i, j, k) = thekh
c      write(iodbug, *) i, j, k, thekl, thekh
	    end do
	 end do
      end do
c Setup output temps
      tout(1) = 1500.
      tout(2) = 2500.
      tout(3) = 3000.
      tout(4) = 4000.
      tout(5) = 5000.
      tout(6) = 6000.
      tout(7) = 7000.
      tout(8) = 8000.
      tout(9) = 9000.
      tout(10) = 10000.
      do i=11, 29
	 tout(i) = eVtoK * tg(1,it(i))
      end do
c Fill up output opacity matrix
      do ic= 1, 5
	 do ir=1, 10
	    do itt=1,29
	       if (it(itt) .eq. 0) then
      temp = (coxkh(ic,ir,itt)-coxkl(ic,ir,itt))*
     1       (zforcox-zhi)/(zhi-zlo) + coxkh(ic,ir,itt)
		  rkout(ic,ir,itt) = temp
	       else
		  rkout(ic,ir,itt) = rkap(ic,ir+incr(itt),it(itt))
	       end if
	    end do
	 end do
      end do
c Do interpolation to fill in gaps
      if (ldoint) then
      do ic= 1, 5
	 do itt=1, 29
	    if (it(itt) .ne. 0) then
	       irr = 1
	       do ir=1, numrho
		  if (rkap(ic, ir, it(itt)) .ne. 0.0) then
		      tk(irr) = log10(rkap(ic, ir, it(itt)))
		      tr(irr) = log10(rho(ir))
		      irr = irr+1
		  end if
	       end do
	       irr = irr-1
	       if (irr .ge. 3) then
		  call spline(tr, tk, irr, 1.0e30, 1.0e30, dtk)
		  do ir=1,10
		     if (rkout(ic,ir,itt) .eq. 0.0) then
			therho = log10(rho(ir+incr(itt)))
			call splint(tr, tk, irr, dtk, therho,
     1                           thek)
			if (thek.lt.-25.0) then
			    thek =-25.0
			end if
			if (thek.gt.25.0) then
			    thek = 25.0
			end if
			rkout(ic, ir, itt) = 10.0**thek
		     end if
		  end do
	       end if
	    end if
	 end do
      end do
      else
c no interpolation, fill gaps with neighbor values in rho
c gaps assumed to be at ends with no more than four zeros in a row
      do ic=1, 5
	 do itt=1, 29
	    do ir=5, 1, -1
	       if (rkout(ic, ir, itt) .eq .0.0) then
		   rkout(ic,ir,itt) = rkout(ic,ir+1, itt)
	       end if
	    end do
	    do ir=6, 10
	       if (rkout(ic, ir, itt) .eq .0.0) then
		   rkout(ic,ir,itt) = rkout(ic,ir-1, itt)
	       end if
	    end do
	 end do
      end do
      end if
c Write out first line: as of Jan 28, 1991 this line contains the
c mass fraction abundances of those elements used in the cox mixture
c scaled to a Z of zforvan, i.e. the mass fractions sum to zforvan.
      write(iodv, 200) cox
  200 format(1p10e8.3e1)
c Write out opacities
      write(iodv, 210) (((rkout(i,j,k), j=1,10), k=1,29),i=1, 5)
  210 format(1p8e9.2)
c Write out temperature (logged)
      do i=1, 29
	 tout(i) = log10(tout(i))
      end do
      write(iodv,220) tout
  220 format(1p7e11.4)
c Write list of 10 densities-logged-before incr offset
      write(iodv, 230) cr
  230 format(1p8e10.3)
c Write out composition X
      write(iodv, 235) (x(ii), ii=1, 5)
  235 format(1p5e10.3)
c Write list of increments
      write(iodv, 240) dincr
  240 format(1p8e10.3)
c January 25, 1991  Added line to opacity table to indicate the 
c     mass fraction of the zforvan mixture.
      sum = 0.0
      do ii=3, 20
        sum = sum + bz(ii)
      enddo
      do ii=3, 20
         bz(ii) = bz(ii)/sum
         bz(ii) = bz(ii) * zforvan
      enddo
      write(iodv, 250) (bz(ii), ii=1, 20)
  250 format(1p8e10.3)
      do i=1, 10
	 coxm(i) = coxm(i) * zforcox
      end do
c January 28, 1991 added scaled to zforcox cox mixture: this mixture is
c the one used to calculate low temp opacities.
      write(iodv, 255) coxm
  255 format(1p8e10.3)
      stop
      end
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c     LOCATE
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Given an array XX of length N, and given a value X, returns
c a value J such that X is between XX(j) and XX(J+1).  X=0 or N
c then out of range.
c
      subroutine locate(xx, n, x, j)
      dimension xx(n)
      jl = 0
      ju = n+1
 10   if (ju-jl.gt.1) then
	 jm = (ju+jl)/2
	 if((xx(n).gt.xx(1)).eqv.(x.gt.xx(jm))) then
	    jl = jm
	 else
	    ju = jm
	 end if
	 go to 10
      end if
      j = jl
      return
      end
